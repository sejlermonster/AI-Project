\chapter{Implementation}
\label{chp:impl}
\section{Hardware}
The chosen hardware for the project was a Lego Mindstorm EV3 robot. With the robot two motors was included and sensors such as a gyroscope and a ultrasound for distance measurement. This is sufficient for solving the kidnapped robot problem.

Using the motors, gyroscope and ultrasound sensor showed some inaccuracy.  The gyroscope has a documented accuracy of +/- 3 degrees and the ultrasonic sensor has a documented accuracy of +/-1 centimeters. Further experiments showed that the ultrasonic sensor could not guarantee any accuracy if the angle to the measured object was no perpendicular. This gave some problems throughout the development and the ultrasonic sensor could yield measurements of for example 90 centimeters when the distance was only 10 centimeters. 

Even though the Lego Mindstorm robot was very inaccurate in some situations it allowed for focus on developing software instead of setting up hardware and sensors. 

\subsection{Devloping for Lego Mindstorm}
A framework(https://github.com/BrianPeek/legoev3/wiki) was choosen to develop for the Lego Mindstorm. This framework allowed to code in C\# and communicate with the Lego Mindstorm robot via Bluetooth from a computer. This allowed for easily developing advanced algorithms for the Lego Mindstorm robot.

\section{Structure and design}
The structure of the developed software is illustrated with a UML class diagram in figure \ref{fig:class}. The main class initializes the world map and the landmarks in it. Main also initializes ParticleFilter, Astar, RobotMotion and RobotSensing. The ParticleFilter class manipulates a list of the type \emph{Particle}. The class \emph{Particle} uses \emph{GaussianNoise} to apply gaussian noise for movement and measurements. 

\myFigure{classDiagram.png}{Class diagram}{fig:class}{1} 

In the following sections the implemented particle filter and A* algorithm will be explained in details.

\section{Robot motion}
Using only P

\section{Particle Filter}
In this project a particle filter was implemented and used for localiation of the robot. Furthermore a class for robot movement and robot sensing was implemented. 

The particle filter is initialized with 3 parameters: the number of particles to be randomly generated and the length on the x and y axis.

\lstset{style=sharpc}
\begin{lstlisting}[caption={Initialization of the particle filter}, label=lst:wheel, mathescape=true]             
_particleFilter.GenerateParticles(_numberOfParticles, world.GetLength(0),
world.GetLength(1));
\end{lstlisting}

After the particles are generated the Particle filter can be used for moving around the particles and resampling. The resampling is implemented as explained in chapter \ref{chp:partFilter} with the resampling wheel algorithm. The implemented resampling function is shown in \emph{BLABLA}. The method is called with a measurement. First a method is called for calculating the importance weight of each particle. This function looks at each particle and calculates the distance to the nearest object in the orientation of the particle. This distance is then compared with the measurement and based on this the weight is calculated.

When the importance weight is calculated a new list of particles is create and then the resampling wheel algorithm is implemented and particles are added to the new list: \emph{particles2}. When the algorithm is done the list of particles is set equal to the new list \emph{particles2} and the weights are normalized.

\lstset{style=sharpc}
\begin{lstlisting}[caption={Resampling wheel}, label=lst:wheel, mathescape=true]                          
public void Resampling(double measurement)
{
	SetImportanceWeight(measurement);
	var particles2 = new List<Particle>();
	var index = random.Next(0, Particles.Count);
	var beta = 0.0;
	var maxParticleWeight = Particles.Max(x => x.Weight);
	var max = maxParticleWeight;
	for (int i = 0; i < Particles.Count; i++)
	{
		beta = beta + random.NextDouble() * 2*max;
		while (beta > Particles[index].Weight)
		{
			beta -= Particles[index].Weight;
			index = (index + 1) % Particles.Count;
		}
		particles2.Add(Particles[index].Clone());
	}
	Particles = particles2;
	NormalizeParticleWeights();
}
\end{lstlisting}

When moving particles forwards or backwards the function MoveParticle is used. This function can be seen in the listing below. The function ensures that the particles are moved in the direction of the particle by using sine and cosine. When the position is set for a particle Gaussian noise is added for the particle. This is done because the movement of the robot is inaccurate. 

\lstset{style=sharpc}
\begin{lstlisting}[caption={Resampling wheel}, label=lst:wheel,  basicstyle=\tiny, mathescape=true]        
public void MoveParticles(double distance)
 {
 	foreach (var particle in Particles)
 	{
 		particle.Position = new Point(
 		particle.Position.X + Math.Cos(particle.OrientationInRadians) * distance, 
 		particle.Position.Y + Math.Sin(particle.OrientationInRadians) * distance); 
 		particle.ApplyGaussianNoiseForPosition();
 	}
 }
\end{lstlisting}

\subsection{Simulation}
This section present a simple simulation of the particle filter. In the example the simulated robot is placed in the world at coordinates (23,64) and will first scan the area, then drive forward twice and scan the area again. When the simulated robot drives forward it also measures the distance in that direction. This is similar to how the lego mindstorm is implemented.

In figure \ref{fig:sim1} the world is initialized. The red dot is the robot, the direction of the robot is displayed by the small line drawn from the square. The particles are the black dots. The landmarks placed in the world are colored green, orange and blue. In the illustration the particles are spread out uniformly in the world. In figure \ref{fig:sim2} the robot has made its first 360 degree scan and taken measurement every 90 degree. The particles are now centered around a few specific places in the world. The location is still very uncertain, this is mainly caused by the symmetry of the world.

\mySubFigure{Simulation/1_Initialized.PNG}{Simulation/2_afterScan.PNG}{}{Intialized particles and world}{Robot makes a 360 degree scan}{fig:sim}{fig:sim1}{fig:sim2}

In figure \ref{sim1} and \ref{sim2} the robot drives forward 10 centimeters twice. The robot takes a measurement after each 10 centimeters. As illustrated the particles are now beginning to be concentrated around the simulated robot.

\mySubFigure{Simulation/3_afterMoveAndMeas.PNG}{Simulation/4_afterMoveAndMeas.PNG}{}{Robot moves forward and measures distance}{Robot moves forward again and measures distance}{fig:sim}{fig:sim1}{fig:sim2}

In figure \ref{fig:5} the robots makes 360 degree scan and takes measurement every 90 degree. After the scan the location is very certain and the particles are all located around the simulated robot.

\myFigure{Simulation/5_afterScan.PNG}{Robot makes a 360 degree scan}{fig:5}{0.4} 

\section{A*}
When the approximate location of the robot in this project is found, an A* algorithm is used to determine a path to the goal destination. The A* algorithm is initialized with 3 parameters: the length on the x an y axis, and the coordinates of the landmarks of the environment in which the robot is placed. 

\lstset{style=sharpc}
\begin{lstlisting}[caption={Initialization of the A* algorithm}, label=lst:Astar_init, mathescape=true]             
_aStarSearch = new AStarSearch(world.GetLength(0), world.GetLength(1),
 _landmarks);
\end{lstlisting}

It uses the environment information to create its heuristic function and to make a path from its own position to the goal destination. The basis for the algorithm is explained in chapter \ref{chp:search} and as it is mentioned the A* algorithm is a more efficient variant of the Search algorithm, meaning the basic functionality is the same. 

When the algorithm has knowledge of the environment, it can begin searching for paths to the goal destination. It does this by exploring adjacent paths to see if they are walkable. However it first checks two things: if it has run out of paths to explore, or if it is already at the goal destination. If neither of these are true it will go into the for-loop illustrated in listing \ref{lst:search_func}. 

\lstset{style=sharpc}
\begin{lstlisting}[caption={Functionality of Search}, label=lst:search_func, mathescape=true]             
for (int i = 0; i < delta.Count; i++)
{
	int x2 = x + delta[i][0];
	int y2 = y + delta[i][1];

	if (x2 >= 0 && x2 < _worldMatrixWithPossiblePaths.GetLength(0) && 
	    y2 >= 0 && y2 < _worldMatrixWithPossiblePaths.GetLength(1))
	{
		if(worldClosed[x2,y2] == 0 && 
		   _worldMatrixWithPossiblePaths[x2,y2] == 0 || 
		   worldClosed[x2, y2] == 99 && 
		   _worldMatrixWithPossiblePaths[x2, y2] == 0)
		{
			int g2 = g + cost;
			var h2 = heuristic[x2, y2];
			var f2 = g2 + h2;
			open.Add(new List<int>()
			{
				f2, g2, h2, x2, y2
			});
			worldClosed[x2, y2] = 2;
			possibleMovements.Add(new List<int>()
			{
				f2, x2, y2
			});
		}
	}
}
\end{lstlisting}

\emph{delta} is a list of directions the robot can go to explore new paths, meaning the loop checks all the directions from the state it is at that moment. For every one of those directions it checks if it can move that way, or if there is an obstacle. It also checks if the direction is even inside the environment in which it is placed. If the direction is indeed a possible path to expand to it will add it to the list of open expansions, it will close the path so it cannot be explored more than once, and it will add it to the list of possible movements.

The A* part of this loop is when the heuristic function is introduced. \emph{g2} is the distance value from the robots position to the path point in question, \emph{h2} is the distance from the path point to the goal, and \emph{f2} is the combination of the two. By combining them the algorithm can chose the shortest path to the goal.

\subsection{Simulation}



\section{Combining Particle Filter and A*}